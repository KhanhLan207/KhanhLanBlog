[{"content":"Các Framework JavaScript Phổ Biến Các framework JavaScript hiện đại đã trở thành công cụ không thể thiếu trong phát triển web. Chúng cung cấp cấu trúc, tối ưu hóa hiệu suất và đơn giản hóa quá trình phát triển ứng dụng web phức tạp.\nTại Sao Cần Framework? Khi phát triển ứng dụng web phức tạp, việc chỉ sử dụng JavaScript thuần (Vanilla JavaScript) có thể gặp nhiều thách thức:\nQuản lý DOM phức tạp: Cập nhật UI thủ công có thể dẫn đến mã nguồn rối rắm và khó bảo trì. Quản lý trạng thái: Theo dõi và đồng bộ trạng thái ứng dụng trở nên phức tạp khi ứng dụng phát triển. Tái sử dụng mã: Khó tạo các thành phần có thể tái sử dụng. Hiệu suất: Tối ưu hóa hiệu suất đòi hỏi nhiều công sức. Quy mô: Khó mở rộng và duy trì các ứng dụng lớn. Các framework giải quyết những vấn đề này bằng cách cung cấp cấu trúc, mẫu thiết kế và công cụ tối ưu.\nReact React là một thư viện JavaScript do Facebook phát triển, tập trung vào việc xây dựng giao diện người dùng thông qua các component.\nĐặc Điểm Chính Component-Based: UI được chia thành các component độc lập, có thể tái sử dụng. Virtual DOM: Cơ chế cập nhật DOM hiệu quả, chỉ render lại những phần thay đổi. JSX: Cú pháp mở rộng JavaScript cho phép viết HTML trong JavaScript. Một chiều (One-way data flow): Dữ liệu chỉ chảy theo một hướng, giúp dễ theo dõi và gỡ lỗi. Hệ sinh thái phong phú: Redux, React Router, Next.js, và nhiều thư viện khác. Ví Dụ Component React import React, { useState } from \u0026#39;react\u0026#39;; function BoĐếm() { const [số, đặtSố] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Bộ Đếm: {số}\u0026lt;/h1\u0026gt; \u0026lt;button onClick={() =\u0026gt; đặtSố(số + 1)}\u0026gt;Tăng\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; đặtSố(số - 1)}\u0026gt;Giảm\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default BoĐếm; Khi Nào Nên Dùng React Ứng dụng một trang (SPA) phức tạp Khi cần hiệu suất cao và UI phản hồi nhanh Khi làm việc trong team lớn (cộng đồng và tài liệu phong phú) Khi cần tích hợp với các ứng dụng native (React Native) Vue.js Vue.js là một framework tiến bộ để xây dựng giao diện người dùng, được thiết kế để dễ tiếp cận và linh hoạt.\nĐặc Điểm Chính Dễ học: Đường cong học tập thoải, dễ tích hợp vào dự án hiện có. Reactive và Composable: Hệ thống phản ứng tự động cập nhật UI khi dữ liệu thay đổi. Template-based: Sử dụng cú pháp template HTML mở rộng. Hai chiều (Two-way binding): Cho phép ràng buộc dữ liệu hai chiều giữa model và view. Hệ sinh thái chính thức: Vuex (quản lý trạng thái), Vue Router, Nuxt.js. Ví Dụ Component Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Bộ Đếm: {{ số }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;tăng\u0026#34;\u0026gt;Tăng\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;giảm\u0026#34;\u0026gt;Giảm\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { số: 0 }; }, methods: { tăng() { this.số += 1; }, giảm() { this.số -= 1; } } }; \u0026lt;/script\u0026gt; Khi Nào Nên Dùng Vue Khi cần framework dễ học và sử dụng Cho các dự án nhỏ đến trung bình Khi cần tích hợp vào dự án hiện có dần dần Khi muốn cân bằng giữa hiệu suất và sự đơn giản Angular Angular là một platform và framework toàn diện do Google phát triển, sử dụng TypeScript để xây dựng ứng dụng client.\nĐặc Điểm Chính TypeScript: Sử dụng TypeScript mặc định, cung cấp kiểm tra kiểu tĩnh. Toàn diện: Cung cấp giải pháp end-to-end với routing, forms, HTTP client tích hợp sẵn. Component-Based: Kiến trúc dựa trên component với templates, logic, và styling. Dependency Injection: Hệ thống DI mạnh mẽ giúp quản lý dependencies. RxJS: Sử dụng Observables để xử lý sự kiện và dữ liệu bất đồng bộ. Ví Dụ Component Angular import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-bo-dem\u0026#39;, template: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Bộ Đếm: {{ số }}\u0026lt;/h1\u0026gt; \u0026lt;button (click)=\u0026#34;tăng()\u0026#34;\u0026gt;Tăng\u0026lt;/button\u0026gt; \u0026lt;button (click)=\u0026#34;giảm()\u0026#34;\u0026gt;Giảm\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ` }) export class BoĐếmComponent { số = 0; tăng() { this.số += 1; } giảm() { this.số -= 1; } } Khi Nào Nên Dùng Angular Cho các ứng dụng doanh nghiệp lớn và phức tạp Khi cần một framework toàn diện với nhiều tính năng tích hợp Khi team đã quen với TypeScript Khi cần kiến trúc rõ ràng và nhất quán cho dự án lớn Svelte Svelte là một cách tiếp cận mới để xây dựng ứng dụng web, chuyển công việc từ runtime sang compile time.\nĐặc Điểm Chính Không Virtual DOM: Biên dịch thành JavaScript tối ưu thay vì sử dụng Virtual DOM. Ít boilerplate: Cú pháp đơn giản, ít mã hơn so với các framework khác. Truly reactive: Phản ứng tích hợp sẵn trong ngôn ngữ. Không runtime: Kích thước bundle nhỏ hơn vì không cần thư viện runtime lớn. Transitions và animations: Hỗ trợ tích hợp sẵn cho animations. Ví Dụ Component Svelte \u0026lt;script\u0026gt; let số = 0; function tăng() { số += 1; } function giảm() { số -= 1; } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Bộ Đếm: {số}\u0026lt;/h1\u0026gt; \u0026lt;button on:click={tăng}\u0026gt;Tăng\u0026lt;/button\u0026gt; \u0026lt;button on:click={giảm}\u0026gt;Giảm\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; Khi Nào Nên Dùng Svelte Khi cần hiệu suất cao và kích thước bundle nhỏ Cho các dự án nhỏ đến trung bình Khi muốn mã nguồn đơn giản và dễ đọc Khi phát triển các widget hoặc thành phần nhúng So Sánh Các Framework Tiêu chí React Vue Angular Svelte Đường cong học tập Trung bình Thấp Cao Thấp Hiệu suất Cao Cao Cao Rất cao Kích thước Trung bình Nhỏ Lớn Rất nhỏ Cộng đồng \u0026amp; Hỗ trợ Rất lớn Lớn Lớn Đang phát triển Tính linh hoạt Cao Cao Trung bình Cao Công cụ phát triển Phong phú Tốt Rất tốt Cơ bản Phù hợp cho SPA, ứng dụng lớn Mọi quy mô Ứng dụng doanh nghiệp Ứng dụng nhỏ-trung bình Làm Thế Nào Để Chọn Framework Phù Hợp? Xem xét yêu cầu dự án: Quy mô, độ phức tạp, và loại ứng dụng. Đánh giá team: Kỹ năng hiện tại và đường cong học tập. Hiệu suất và quy mô: Yêu cầu về hiệu suất và khả năng mở rộng. Hệ sinh thái: Thư viện, công cụ, và hỗ trợ cộng đồng. Tương lai: Sự phát triển và hỗ trợ dài hạn của framework. Kết Luận Mỗi framework JavaScript đều có điểm mạnh và điểm yếu riêng. Không có framework nào \u0026ldquo;tốt nhất\u0026rdquo; cho mọi tình huống. Việc lựa chọn phụ thuộc vào yêu cầu cụ thể của dự án, kỹ năng của team, và các yếu tố khác.\nTrong thế giới phát triển web hiện đại, việc hiểu và sử dụng thành thạo ít nhất một framework JavaScript là kỹ năng quan trọng cho mọi lập trình viên front-end.\n","permalink":"http://localhost:1313/posts/javascript-frameworks/","summary":"\u003ch1 id=\"các-framework-javascript-phổ-biến\"\u003eCác Framework JavaScript Phổ Biến\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"JavaScript Frameworks\" loading=\"lazy\" src=\"/images/posts/javascript-frameworks.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eCác framework JavaScript hiện đại đã trở thành công cụ không thể thiếu trong phát triển web. Chúng cung cấp cấu trúc, tối ưu hóa hiệu suất và đơn giản hóa quá trình phát triển ứng dụng web phức tạp.\u003c/p\u003e\n\u003ch2 id=\"tại-sao-cần-framework\"\u003eTại Sao Cần Framework?\u003c/h2\u003e\n\u003cp\u003eKhi phát triển ứng dụng web phức tạp, việc chỉ sử dụng JavaScript thuần (Vanilla JavaScript) có thể gặp nhiều thách thức:\u003c/p\u003e","title":"Các Framework JavaScript Phổ Biến"},{"content":"Cơ Bản Về Java - Ngôn Ngữ Lập Trình Mạnh Mẽ Java là một ngôn ngữ lập trình hướng đối tượng, mạnh mẽ và được sử dụng rộng rãi trong nhiều lĩnh vực từ phát triển ứng dụng di động đến hệ thống doanh nghiệp lớn.\nLịch Sử Phát Triển Java được phát triển bởi James Gosling tại Sun Microsystems (hiện thuộc Oracle) vào năm 1995. Ngôn ngữ này được thiết kế với triết lý \u0026ldquo;Write Once, Run Anywhere\u0026rdquo; (WORA), cho phép mã nguồn Java có thể chạy trên bất kỳ thiết bị nào hỗ trợ Java mà không cần biên dịch lại.\nĐặc Điểm Của Java Hướng đối tượng: Java là ngôn ngữ lập trình hướng đối tượng, mọi thứ trong Java đều là đối tượng.\nĐộc lập nền tảng: Mã Java được biên dịch thành bytecode, có thể chạy trên bất kỳ thiết bị nào có cài đặt Java Virtual Machine (JVM).\nĐơn giản: Java được thiết kế để dễ học và sử dụng, loại bỏ các tính năng phức tạp như con trỏ và quản lý bộ nhớ thủ công.\nBảo mật: Java có nhiều tính năng bảo mật tích hợp, giúp phát triển ứng dụng an toàn.\nMạnh mẽ: Java có cơ chế kiểm tra lỗi mạnh mẽ, quản lý bộ nhớ tự động và xử lý ngoại lệ.\nCài Đặt Java Để bắt đầu với Java, bạn cần cài đặt Java Development Kit (JDK):\nTruy cập trang web chính thức của Oracle để tải JDK Cài đặt JDK theo hướng dẫn Thiết lập biến môi trường JAVA_HOME và PATH Chương Trình Java Đầu Tiên public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Xin chào, thế giới!\u0026#34;); } } Để biên dịch và chạy chương trình:\njavac HelloWorld.java java HelloWorld Cấu Trúc Cơ Bản Của Java Biến và Kiểu Dữ Liệu Java có hai loại kiểu dữ liệu:\nKiểu nguyên thủy: int, float, double, boolean, char\u0026hellip; Kiểu tham chiếu: String, Array, Class\u0026hellip; // Khai báo biến int soNguyen = 10; double soThuc = 10.5; boolean dung = true; char kyTu = \u0026#39;A\u0026#39;; String chuoi = \u0026#34;Xin chào\u0026#34;; Điều Kiện và Vòng Lặp // Câu lệnh if-else if (dieu_kien) { // Mã thực thi nếu điều kiện đúng } else { // Mã thực thi nếu điều kiện sai } // Vòng lặp for for (int i = 0; i \u0026lt; 10; i++) { // Mã thực thi lặp lại } // Vòng lặp while while (dieu_kien) { // Mã thực thi lặp lại } Kết Luận Java là một ngôn ngữ lập trình mạnh mẽ và linh hoạt, phù hợp cho nhiều loại ứng dụng khác nhau. Với cú pháp rõ ràng và hệ sinh thái phong phú, Java là lựa chọn tuyệt vời cho cả người mới bắt đầu và lập trình viên có kinh nghiệm.\nTrong các bài viết tiếp theo, chúng ta sẽ đi sâu hơn vào các khía cạnh nâng cao của Java như lập trình hướng đối tượng, xử lý ngoại lệ, và các framework phổ biến.\n","permalink":"http://localhost:1313/posts/java-basics/","summary":"\u003ch1 id=\"cơ-bản-về-java---ngôn-ngữ-lập-trình-mạnh-mẽ\"\u003eCơ Bản Về Java - Ngôn Ngữ Lập Trình Mạnh Mẽ\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Java Logo\" loading=\"lazy\" src=\"/images/posts/java-header.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eJava là một ngôn ngữ lập trình hướng đối tượng, mạnh mẽ và được sử dụng rộng rãi trong nhiều lĩnh vực từ phát triển ứng dụng di động đến hệ thống doanh nghiệp lớn.\u003c/p\u003e\n\u003ch2 id=\"lịch-sử-phát-triển\"\u003eLịch Sử Phát Triển\u003c/h2\u003e\n\u003cp\u003eJava được phát triển bởi James Gosling tại Sun Microsystems (hiện thuộc Oracle) vào năm 1995. Ngôn ngữ này được thiết kế với triết lý \u0026ldquo;Write Once, Run Anywhere\u0026rdquo; (WORA), cho phép mã nguồn Java có thể chạy trên bất kỳ thiết bị nào hỗ trợ Java mà không cần biên dịch lại.\u003c/p\u003e","title":"Cơ Bản Về Java - Ngôn Ngữ Lập Trình Mạnh Mẽ"},{"content":"Giới Thiệu Về JavaScript - Ngôn Ngữ Của Web JavaScript là ngôn ngữ lập trình phổ biến nhất trên web, cho phép tạo ra các trang web động và tương tác với người dùng.\nLịch Sử JavaScript JavaScript được tạo ra bởi Brendan Eich tại Netscape vào năm 1995, ban đầu có tên là Mocha, sau đó đổi thành LiveScript và cuối cùng là JavaScript. Mặc dù có \u0026ldquo;Java\u0026rdquo; trong tên, nhưng JavaScript hoàn toàn khác biệt với Java.\nĐặc Điểm Của JavaScript Ngôn ngữ kịch bản phía client: JavaScript chủ yếu chạy trên trình duyệt của người dùng. Đa nền tảng: Hoạt động trên nhiều trình duyệt và thiết bị khác nhau. Hướng đối tượng: Sử dụng các khái niệm lập trình hướng đối tượng. Động: Kiểu dữ liệu được xác định tại thời điểm chạy. Xử lý sự kiện: Cho phép phản hồi các hành động của người dùng. Cách Sử Dụng JavaScript JavaScript có thể được nhúng trực tiếp vào HTML hoặc được liên kết từ một tệp riêng biệt.\nNhúng Trực Tiếp \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;JavaScript Demo\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; function xinChao() { alert(\u0026#34;Xin chào từ JavaScript!\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;xinChao()\u0026#34;\u0026gt;Nhấn vào đây\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liên Kết Từ Tệp Ngoài \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;JavaScript Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;xinChao()\u0026#34;\u0026gt;Nhấn vào đây\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Với nội dung tệp script.js:\nfunction xinChao() { alert(\u0026#34;Xin chào từ JavaScript!\u0026#34;); } Cú Pháp Cơ Bản Biến và Kiểu Dữ Liệu JavaScript có ba cách khai báo biến: var, let, và const.\n// Khai báo biến với var (phạm vi function) var x = 10; // Khai báo biến với let (phạm vi block) let y = 20; // Khai báo hằng số với const const PI = 3.14; // Các kiểu dữ liệu let so = 10; // Number let chuoi = \u0026#34;JavaScript\u0026#34;; // String let dung = true; // Boolean let mang = [1, 2, 3]; // Array let doiTuong = { // Object ten: \u0026#34;JavaScript\u0026#34;, namRaMat: 1995 }; let khongXacDinh = undefined; // Undefined let khongCoGiaTri = null; // Null Hàm // Khai báo hàm function tinhTong(a, b) { return a + b; } // Gọi hàm let tong = tinhTong(5, 3); console.log(\u0026#34;Tổng: \u0026#34; + tong); // Arrow function (ES6) const nhan = (a, b) =\u0026gt; a * b; console.log(\u0026#34;Tích: \u0026#34; + nhan(5, 3)); Điều Kiện và Vòng Lặp // Câu lệnh if-else let diem = 85; if (diem \u0026gt;= 90) { console.log(\u0026#34;Xuất sắc\u0026#34;); } else if (diem \u0026gt;= 80) { console.log(\u0026#34;Giỏi\u0026#34;); } else if (diem \u0026gt;= 70) { console.log(\u0026#34;Khá\u0026#34;); } else { console.log(\u0026#34;Trung bình\u0026#34;); } // Vòng lặp for for (let i = 0; i \u0026lt; 5; i++) { console.log(\u0026#34;Số: \u0026#34; + i); } // Vòng lặp while let j = 0; while (j \u0026lt; 5) { console.log(\u0026#34;Số: \u0026#34; + j); j++; } // Vòng lặp for...of (ES6) let mang = [1, 2, 3, 4, 5]; for (let phanTu of mang) { console.log(phanTu); } // Vòng lặp for...in let doiTuong = { ten: \u0026#34;JavaScript\u0026#34;, namRaMat: 1995, tacGia: \u0026#34;Brendan Eich\u0026#34; }; for (let thuocTinh in doiTuong) { console.log(thuocTinh + \u0026#34;: \u0026#34; + doiTuong[thuocTinh]); } DOM Manipulation JavaScript có thể thay đổi nội dung, cấu trúc và kiểu của trang web thông qua Document Object Model (DOM).\n// Lấy phần tử theo ID let tieuDe = document.getElementById(\u0026#34;tieuDe\u0026#34;); // Thay đổi nội dung tieuDe.innerHTML = \u0026#34;Tiêu đề mới\u0026#34;; // Thay đổi kiểu tieuDe.style.color = \u0026#34;blue\u0026#34;; tieuDe.style.fontSize = \u0026#34;24px\u0026#34;; // Tạo phần tử mới let doanVan = document.createElement(\u0026#34;p\u0026#34;); doanVan.innerHTML = \u0026#34;Đây là một đoạn văn mới.\u0026#34;; // Thêm phần tử vào trang document.body.appendChild(doanVan); // Xử lý sự kiện let nutBam = document.getElementById(\u0026#34;nutBam\u0026#34;); nutBam.addEventListener(\u0026#34;click\u0026#34;, function() { alert(\u0026#34;Bạn đã nhấn vào nút!\u0026#34;); }); Xử Lý Bất Đồng Bộ JavaScript xử lý các tác vụ bất đồng bộ thông qua callbacks, promises, và async/await.\n// Callback function taiDuLieu(callback) { setTimeout(function() { console.log(\u0026#34;Đã tải dữ liệu\u0026#34;); callback(\u0026#34;Dữ liệu\u0026#34;); }, 2000); } taiDuLieu(function(data) { console.log(\u0026#34;Dữ liệu nhận được: \u0026#34; + data); }); // Promise function taiDuLieuPromise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;Đã tải dữ liệu\u0026#34;); resolve(\u0026#34;Dữ liệu\u0026#34;); }, 2000); }); } taiDuLieuPromise() .then(data =\u0026gt; console.log(\u0026#34;Dữ liệu nhận được: \u0026#34; + data)) .catch(error =\u0026gt; console.error(\u0026#34;Lỗi: \u0026#34; + error)); // Async/Await (ES8) async function xuLyDuLieu() { try { const data = await taiDuLieuPromise(); console.log(\u0026#34;Dữ liệu nhận được: \u0026#34; + data); } catch (error) { console.error(\u0026#34;Lỗi: \u0026#34; + error); } } xuLyDuLieu(); Kết Luận JavaScript là một ngôn ngữ mạnh mẽ và linh hoạt, đóng vai trò quan trọng trong phát triển web hiện đại. Với sự phát triển không ngừng của các framework và thư viện như React, Angular, và Vue.js, JavaScript đã mở rộng phạm vi của mình từ phía client sang cả phía server (Node.js).\nTrong các bài viết tiếp theo, chúng ta sẽ đi sâu hơn vào các khía cạnh nâng cao của JavaScript như ES6+, các framework phổ biến, và các kỹ thuật tối ưu hiệu suất.\n","permalink":"http://localhost:1313/posts/javascript-intro/","summary":"\u003ch1 id=\"giới-thiệu-về-javascript---ngôn-ngữ-của-web\"\u003eGiới Thiệu Về JavaScript - Ngôn Ngữ Của Web\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"JavaScript Logo\" loading=\"lazy\" src=\"/images/posts/javascript-header.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eJavaScript là ngôn ngữ lập trình phổ biến nhất trên web, cho phép tạo ra các trang web động và tương tác với người dùng.\u003c/p\u003e\n\u003ch2 id=\"lịch-sử-javascript\"\u003eLịch Sử JavaScript\u003c/h2\u003e\n\u003cp\u003eJavaScript được tạo ra bởi Brendan Eich tại Netscape vào năm 1995, ban đầu có tên là Mocha, sau đó đổi thành LiveScript và cuối cùng là JavaScript. Mặc dù có \u0026ldquo;Java\u0026rdquo; trong tên, nhưng JavaScript hoàn toàn khác biệt với Java.\u003c/p\u003e","title":"Giới Thiệu Về JavaScript - Ngôn Ngữ Của Web"},{"content":"Java Collections Framework - Cấu Trúc Dữ Liệu Trong Java Java Collections Framework cung cấp một kiến trúc để lưu trữ và thao tác với các nhóm đối tượng. Framework này bao gồm các interfaces, implementations và algorithms.\nTổng Quan Về Collections Framework Collections Framework trong Java bao gồm:\nInterfaces: Các abstract data types đại diện cho collections Implementations: Các lớp cụ thể triển khai các interfaces Algorithms: Các phương thức thực hiện các thao tác hữu ích như tìm kiếm và sắp xếp Các Interface Chính Collection Interface Interface cơ bản nhất trong hierarchy, định nghĩa các thao tác cơ bản như add, remove, contains.\nCollection\u0026lt;String\u0026gt; collection = new ArrayList\u0026lt;\u0026gt;(); collection.add(\u0026#34;Java\u0026#34;); collection.add(\u0026#34;Python\u0026#34;); collection.add(\u0026#34;C++\u0026#34;); System.out.println(\u0026#34;Số phần tử: \u0026#34; + collection.size()); List Interface List là một collection có thứ tự và cho phép các phần tử trùng lặp.\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Python\u0026#34;); list.add(\u0026#34;Java\u0026#34;); // Cho phép trùng lặp System.out.println(\u0026#34;Phần tử ở vị trí 1: \u0026#34; + list.get(1)); Set Interface Set là một collection không cho phép các phần tử trùng lặp.\nSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;Java\u0026#34;); set.add(\u0026#34;Python\u0026#34;); set.add(\u0026#34;Java\u0026#34;); // Không được thêm vào vì đã tồn tại System.out.println(\u0026#34;Số phần tử trong set: \u0026#34; + set.size()); // Kết quả: 2 Map Interface Map là một đối tượng ánh xạ mỗi key tới một giá trị.\nMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;Java\u0026#34;, 1995); map.put(\u0026#34;Python\u0026#34;, 1991); map.put(\u0026#34;JavaScript\u0026#34;, 1995); System.out.println(\u0026#34;Năm ra đời của Java: \u0026#34; + map.get(\u0026#34;Java\u0026#34;)); Các Lớp Triển Khai Phổ Biến ArrayList ArrayList là một mảng động, cho phép thêm hoặc xóa phần tử sau khi mảng được tạo.\nArrayList\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;Java\u0026#34;); arrayList.add(\u0026#34;Python\u0026#34;); arrayList.add(\u0026#34;C++\u0026#34;); // Duyệt qua các phần tử for (String language : arrayList) { System.out.println(language); } LinkedList LinkedList triển khai List và Deque interfaces, cho phép thao tác hiệu quả ở đầu và cuối danh sách.\nLinkedList\u0026lt;String\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); linkedList.add(\u0026#34;Java\u0026#34;); linkedList.add(\u0026#34;Python\u0026#34;); linkedList.addFirst(\u0026#34;C++\u0026#34;); // Thêm vào đầu linkedList.addLast(\u0026#34;JavaScript\u0026#34;); // Thêm vào cuối System.out.println(\u0026#34;Phần tử đầu tiên: \u0026#34; + linkedList.getFirst()); System.out.println(\u0026#34;Phần tử cuối cùng: \u0026#34; + linkedList.getLast()); HashSet HashSet là một Set không đảm bảo thứ tự các phần tử.\nHashSet\u0026lt;String\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); hashSet.add(\u0026#34;Java\u0026#34;); hashSet.add(\u0026#34;Python\u0026#34;); hashSet.add(\u0026#34;C++\u0026#34;); // Kiểm tra phần tử tồn tại System.out.println(\u0026#34;Có chứa Java không? \u0026#34; + hashSet.contains(\u0026#34;Java\u0026#34;)); TreeSet TreeSet là một Set sắp xếp các phần tử theo thứ tự tăng dần.\nTreeSet\u0026lt;String\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(\u0026#34;Java\u0026#34;); treeSet.add(\u0026#34;Python\u0026#34;); treeSet.add(\u0026#34;C++\u0026#34;); treeSet.add(\u0026#34;JavaScript\u0026#34;); // Các phần tử được sắp xếp theo thứ tự for (String language : treeSet) { System.out.println(language); } HashMap HashMap lưu trữ các cặp key-value, không đảm bảo thứ tự.\nHashMap\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;Java\u0026#34;, 1995); hashMap.put(\u0026#34;Python\u0026#34;, 1991); hashMap.put(\u0026#34;JavaScript\u0026#34;, 1995); // Duyệt qua các cặp key-value for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : hashMap.entrySet()) { System.out.println(entry.getKey() + \u0026#34; ra đời năm \u0026#34; + entry.getValue()); } TreeMap TreeMap lưu trữ các cặp key-value, sắp xếp theo thứ tự tăng dần của key.\nTreeMap\u0026lt;String, Integer\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); treeMap.put(\u0026#34;Java\u0026#34;, 1995); treeMap.put(\u0026#34;Python\u0026#34;, 1991); treeMap.put(\u0026#34;JavaScript\u0026#34;, 1995); treeMap.put(\u0026#34;C++\u0026#34;, 1983); // Các key được sắp xếp theo thứ tự for (String key : treeMap.keySet()) { System.out.println(key + \u0026#34; ra đời năm \u0026#34; + treeMap.get(key)); } Các Thuật Toán Hữu Ích Java Collections Framework cung cấp các thuật toán hữu ích thông qua lớp Collections:\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Python\u0026#34;); list.add(\u0026#34;C++\u0026#34;); list.add(\u0026#34;JavaScript\u0026#34;); // Sắp xếp Collections.sort(list); System.out.println(\u0026#34;Danh sách sau khi sắp xếp: \u0026#34; + list); // Đảo ngược Collections.reverse(list); System.out.println(\u0026#34;Danh sách sau khi đảo ngược: \u0026#34; + list); // Tìm kiếm nhị phân (yêu cầu danh sách đã sắp xếp) Collections.sort(list); int index = Collections.binarySearch(list, \u0026#34;Python\u0026#34;); System.out.println(\u0026#34;Python ở vị trí: \u0026#34; + index); // Xáo trộn Collections.shuffle(list); System.out.println(\u0026#34;Danh sách sau khi xáo trộn: \u0026#34; + list); Kết Luận Java Collections Framework là một công cụ mạnh mẽ để quản lý và thao tác với dữ liệu trong Java. Việc hiểu và sử dụng đúng các collection sẽ giúp bạn viết mã hiệu quả và tối ưu hơn.\nTrong các bài viết tiếp theo, chúng ta sẽ đi sâu hơn vào các khía cạnh nâng cao của Collections Framework như concurrent collections và các kỹ thuật tối ưu hiệu suất.\n","permalink":"http://localhost:1313/posts/java-collections/","summary":"\u003ch1 id=\"java-collections-framework---cấu-trúc-dữ-liệu-trong-java\"\u003eJava Collections Framework - Cấu Trúc Dữ Liệu Trong Java\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Java Collections\" loading=\"lazy\" src=\"/images/posts/java-collections.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eJava Collections Framework cung cấp một kiến trúc để lưu trữ và thao tác với các nhóm đối tượng. Framework này bao gồm các interfaces, implementations và algorithms.\u003c/p\u003e\n\u003ch2 id=\"tổng-quan-về-collections-framework\"\u003eTổng Quan Về Collections Framework\u003c/h2\u003e\n\u003cp\u003eCollections Framework trong Java bao gồm:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInterfaces\u003c/strong\u003e: Các abstract data types đại diện cho collections\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImplementations\u003c/strong\u003e: Các lớp cụ thể triển khai các interfaces\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAlgorithms\u003c/strong\u003e: Các phương thức thực hiện các thao tác hữu ích như tìm kiếm và sắp xếp\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"các-interface-chính\"\u003eCác Interface Chính\u003c/h2\u003e\n\u003ch3 id=\"collection-interface\"\u003eCollection Interface\u003c/h3\u003e\n\u003cp\u003eInterface cơ bản nhất trong hierarchy, định nghĩa các thao tác cơ bản như add, remove, contains.\u003c/p\u003e","title":"Java Collections Framework - Cấu Trúc Dữ Liệu Trong Java"},{"content":"Spring Boot - Framework Java Hiện Đại Spring Boot là một framework phổ biến cho phát triển ứng dụng Java, giúp đơn giản hóa quá trình cấu hình và triển khai ứng dụng Spring.\nGiới Thiệu Về Spring Boot Spring Boot là một phần của hệ sinh thái Spring Framework, được phát triển bởi Pivotal Team. Nó cung cấp cách tiếp cận \u0026ldquo;opinionated\u0026rdquo; để xây dựng ứng dụng Spring, giúp giảm thiểu thời gian cấu hình và tăng năng suất phát triển.\nƯu Điểm Của Spring Boot Cấu hình tự động: Spring Boot tự động cấu hình ứng dụng dựa trên các phụ thuộc có trong classpath. Máy chủ nhúng: Tích hợp sẵn Tomcat, Jetty hoặc Undertow, không cần triển khai WAR files. Starter dependencies: Đơn giản hóa cấu hình Maven/Gradle với các starter dependencies. Actuator: Cung cấp các tính năng sẵn có để giám sát và quản lý ứng dụng. Không cần XML: Cấu hình dựa trên Java, annotations và YAML/properties. Tạo Ứng Dụng Spring Boot Đầu Tiên Sử Dụng Spring Initializr Cách đơn giản nhất để tạo ứng dụng Spring Boot là sử dụng Spring Initializr:\nTruy cập https://start.spring.io/ Chọn Maven hoặc Gradle Chọn ngôn ngữ Java Chọn phiên bản Spring Boot Điền thông tin Group, Artifact Thêm các dependencies (ví dụ: Spring Web, JPA, MySQL) Tạo và tải về dự án Cấu Trúc Dự Án my-spring-boot-app/ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── com/ │ │ │ └── example/ │ │ │ └── myapp/ │ │ │ ├── MySpringBootApplication.java │ │ │ ├── controller/ │ │ │ ├── model/ │ │ │ ├── repository/ │ │ │ └── service/ │ │ └── resources/ │ │ ├── application.properties │ │ ├── static/ │ │ └── templates/ │ └── test/ │ └── java/ │ └── com/ │ └── example/ │ └── myapp/ │ └── MySpringBootApplicationTests.java ├── pom.xml (hoặc build.gradle) └── README.md Lớp Chính package com.example.myapp; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MySpringBootApplication { public static void main(String[] args) { SpringApplication.run(MySpringBootApplication.class, args); } } Xây Dựng REST API Model package com.example.myapp.model; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class SanPham { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String ten; private String moTa; private double gia; // Constructors, Getters và Setters public SanPham() { } public SanPham(String ten, String moTa, double gia) { this.ten = ten; this.moTa = moTa; this.gia = gia; } // Getters và Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTen() { return ten; } public void setTen(String ten) { this.ten = ten; } public String getMoTa() { return moTa; } public void setMoTa(String moTa) { this.moTa = moTa; } public double getGia() { return gia; } public void setGia(double gia) { this.gia = gia; } } Repository package com.example.myapp.repository; import com.example.myapp.model.SanPham; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; import java.util.List; @Repository public interface SanPhamRepository extends JpaRepository\u0026lt;SanPham, Long\u0026gt; { List\u0026lt;SanPham\u0026gt; findByTenContaining(String ten); } Service package com.example.myapp.service; import com.example.myapp.model.SanPham; import com.example.myapp.repository.SanPhamRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; import java.util.Optional; @Service public class SanPhamService { private final SanPhamRepository sanPhamRepository; @Autowired public SanPhamService(SanPhamRepository sanPhamRepository) { this.sanPhamRepository = sanPhamRepository; } public List\u0026lt;SanPham\u0026gt; layTatCaSanPham() { return sanPhamRepository.findAll(); } public Optional\u0026lt;SanPham\u0026gt; laySanPhamTheoId(Long id) { return sanPhamRepository.findById(id); } public List\u0026lt;SanPham\u0026gt; timSanPhamTheoTen(String ten) { return sanPhamRepository.findByTenContaining(ten); } public SanPham luuSanPham(SanPham sanPham) { return sanPhamRepository.save(sanPham); } public void xoaSanPham(Long id) { sanPhamRepository.deleteById(id); } } Controller package com.example.myapp.controller; import com.example.myapp.model.SanPham; import com.example.myapp.service.SanPhamService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.List; import java.util.Optional; @RestController @RequestMapping(\u0026#34;/api/sanpham\u0026#34;) public class SanPhamController { private final SanPhamService sanPhamService; @Autowired public SanPhamController(SanPhamService sanPhamService) { this.sanPhamService = sanPhamService; } @GetMapping public ResponseEntity\u0026lt;List\u0026lt;SanPham\u0026gt;\u0026gt; layTatCaSanPham() { List\u0026lt;SanPham\u0026gt; danhSachSanPham = sanPhamService.layTatCaSanPham(); return new ResponseEntity\u0026lt;\u0026gt;(danhSachSanPham, HttpStatus.OK); } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;SanPham\u0026gt; laySanPhamTheoId(@PathVariable Long id) { Optional\u0026lt;SanPham\u0026gt; sanPham = sanPhamService.laySanPhamTheoId(id); return sanPham.map(value -\u0026gt; new ResponseEntity\u0026lt;\u0026gt;(value, HttpStatus.OK)) .orElseGet(() -\u0026gt; new ResponseEntity\u0026lt;\u0026gt;(HttpStatus.NOT_FOUND)); } @GetMapping(\u0026#34;/tim\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;SanPham\u0026gt;\u0026gt; timSanPhamTheoTen(@RequestParam String ten) { List\u0026lt;SanPham\u0026gt; danhSachSanPham = sanPhamService.timSanPhamTheoTen(ten); return new ResponseEntity\u0026lt;\u0026gt;(danhSachSanPham, HttpStatus.OK); } @PostMapping public ResponseEntity\u0026lt;SanPham\u0026gt; themSanPham(@RequestBody SanPham sanPham) { SanPham sanPhamMoi = sanPhamService.luuSanPham(sanPham); return new ResponseEntity\u0026lt;\u0026gt;(sanPhamMoi, HttpStatus.CREATED); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;SanPham\u0026gt; capNhatSanPham(@PathVariable Long id, @RequestBody SanPham sanPham) { Optional\u0026lt;SanPham\u0026gt; sanPhamHienTai = sanPhamService.laySanPhamTheoId(id); if (sanPhamHienTai.isPresent()) { sanPham.setId(id); SanPham sanPhamCapNhat = sanPhamService.luuSanPham(sanPham); return new ResponseEntity\u0026lt;\u0026gt;(sanPhamCapNhat, HttpStatus.OK); } else { return new ResponseEntity\u0026lt;\u0026gt;(HttpStatus.NOT_FOUND); } } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; xoaSanPham(@PathVariable Long id) { Optional\u0026lt;SanPham\u0026gt; sanPham = sanPhamService.laySanPhamTheoId(id); if (sanPham.isPresent()) { sanPhamService.xoaSanPham(id); return new ResponseEntity\u0026lt;\u0026gt;(HttpStatus.NO_CONTENT); } else { return new ResponseEntity\u0026lt;\u0026gt;(HttpStatus.NOT_FOUND); } } } Cấu Hình Cơ Sở Dữ Liệu application.properties # Cấu hình cơ sở dữ liệu spring.datasource.url=jdbc:mysql://localhost:3306/myapp_db spring.datasource.username=root spring.datasource.password=password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # Cấu hình JPA/Hibernate spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # Cấu hình server server.port=8080 Spring Boot Security Spring Security giúp bảo mật ứng dụng Spring Boot:\npackage com.example.myapp.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.provisioning.InMemoryUserDetailsManager; import org.springframework.security.web.SecurityFilterChain; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/home\u0026#34;).permitAll() .antMatchers(\u0026#34;/api/**\u0026#34;).authenticated() .and() .formLogin() .loginPage(\u0026#34;/login\u0026#34;) .permitAll() .and() .logout() .permitAll(); return http.build(); } @Bean public UserDetailsService userDetailsService() { UserDetails user = User.withDefaultPasswordEncoder() .username(\u0026#34;user\u0026#34;) .password(\u0026#34;password\u0026#34;) .roles(\u0026#34;USER\u0026#34;) .build(); return new InMemoryUserDetailsManager(user); } } Thử Nghiệm Ứng Dụng Để chạy ứng dụng Spring Boot:\n./mvnw spring-boot:run hoặc\n./gradlew bootRun Kết Luận Spring Boot là một framework mạnh mẽ cho phát triển ứng dụng Java, giúp đơn giản hóa quá trình cấu hình và triển khai. Với các tính năng như cấu hình tự động, máy chủ nhúng, và starter dependencies, Spring Boot giúp các nhà phát triển tập trung vào logic kinh doanh thay vì lo lắng về cấu hình.\nTrong các bài viết tiếp theo, chúng ta sẽ đi sâu hơn vào các tính năng nâng cao của Spring Boot như microservices, Spring Cloud, và Spring Data.\n","permalink":"http://localhost:1313/posts/java-spring-boot/","summary":"\u003ch1 id=\"spring-boot---framework-java-hiện-đại\"\u003eSpring Boot - Framework Java Hiện Đại\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Spring Boot\" loading=\"lazy\" src=\"/images/posts/spring-boot.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eSpring Boot là một framework phổ biến cho phát triển ứng dụng Java, giúp đơn giản hóa quá trình cấu hình và triển khai ứng dụng Spring.\u003c/p\u003e\n\u003ch2 id=\"giới-thiệu-về-spring-boot\"\u003eGiới Thiệu Về Spring Boot\u003c/h2\u003e\n\u003cp\u003eSpring Boot là một phần của hệ sinh thái Spring Framework, được phát triển bởi Pivotal Team. Nó cung cấp cách tiếp cận \u0026ldquo;opinionated\u0026rdquo; để xây dựng ứng dụng Spring, giúp giảm thiểu thời gian cấu hình và tăng năng suất phát triển.\u003c/p\u003e","title":"Spring Boot - Framework Java Hiện Đại"},{"content":"JavaScript Bất Đồng Bộ - Promises, Async/Await JavaScript là ngôn ngữ đơn luồng (single-threaded), nhưng có thể xử lý các tác vụ bất đồng bộ thông qua các cơ chế như callbacks, promises, và async/await.\nTại Sao Cần Lập Trình Bất Đồng Bộ? Lập trình bất đồng bộ cho phép thực hiện các tác vụ mà không chặn luồng chính, đặc biệt hữu ích cho:\nGọi API Đọc/ghi tệp Truy vấn cơ sở dữ liệu Tải tài nguyên (hình ảnh, video) Thực hiện các tác vụ tốn thời gian Callbacks Callbacks là cách truyền thống nhất để xử lý bất đồng bộ trong JavaScript.\nfunction taiDuLieu(url, callback) { console.log(`Bắt đầu tải dữ liệu từ ${url}`); setTimeout(() =\u0026gt; { const duLieu = { id: 1, ten: \u0026#34;Dữ liệu từ \u0026#34; + url }; callback(duLieu); }, 2000); } taiDuLieu(\u0026#34;api.example.com/data\u0026#34;, function(duLieu) { console.log(\u0026#34;Dữ liệu đã tải xong:\u0026#34;, duLieu); }); console.log(\u0026#34;Tiếp tục thực hiện các tác vụ khác...\u0026#34;); Callback Hell Khi có nhiều tác vụ bất đồng bộ lồng nhau, code có thể trở nên khó đọc và bảo trì, hiện tượng này được gọi là \u0026ldquo;callback hell\u0026rdquo; hoặc \u0026ldquo;pyramid of doom\u0026rdquo;.\ntaiDuLieu(\u0026#34;api.example.com/users\u0026#34;, function(users) { console.log(\u0026#34;Đã tải danh sách người dùng\u0026#34;); taiDuLieu(`api.example.com/users/${users[0].id}/posts`, function(posts) { console.log(\u0026#34;Đã tải bài viết của người dùng\u0026#34;); taiDuLieu(`api.example.com/posts/${posts[0].id}/comments`, function(comments) { console.log(\u0026#34;Đã tải bình luận của bài viết\u0026#34;); // Và còn nhiều lồng nhau nữa... }); }); }); Promises Promises được giới thiệu để giải quyết vấn đề callback hell, cung cấp cách tốt hơn để xử lý các tác vụ bất đồng bộ.\nfunction taiDuLieu(url) { return new Promise((resolve, reject) =\u0026gt; { console.log(`Bắt đầu tải dữ liệu từ ${url}`); setTimeout(() =\u0026gt; { if (url.includes(\u0026#34;error\u0026#34;)) { reject(new Error(\u0026#34;Không thể tải dữ liệu\u0026#34;)); } else { const duLieu = { id: 1, ten: \u0026#34;Dữ liệu từ \u0026#34; + url }; resolve(duLieu); } }, 2000); }); } taiDuLieu(\u0026#34;api.example.com/data\u0026#34;) .then(duLieu =\u0026gt; { console.log(\u0026#34;Dữ liệu đã tải xong:\u0026#34;, duLieu); return taiDuLieu(\u0026#34;api.example.com/more-data\u0026#34;); }) .then(duLieuThem =\u0026gt; { console.log(\u0026#34;Dữ liệu thêm đã tải xong:\u0026#34;, duLieuThem); }) .catch(error =\u0026gt; { console.error(\u0026#34;Đã xảy ra lỗi:\u0026#34;, error.message); }) .finally(() =\u0026gt; { console.log(\u0026#34;Quá trình tải dữ liệu đã hoàn tất\u0026#34;); }); console.log(\u0026#34;Tiếp tục thực hiện các tác vụ khác...\u0026#34;); Trạng Thái Của Promise Một Promise có thể ở một trong ba trạng thái:\nPending: Trạng thái ban đầu, chưa hoàn thành hoặc bị từ chối Fulfilled: Tác vụ đã hoàn thành thành công Rejected: Tác vụ đã thất bại Promise.all Promise.all cho phép thực hiện nhiều promises đồng thời và đợi tất cả hoàn thành.\nconst promise1 = taiDuLieu(\u0026#34;api.example.com/users\u0026#34;); const promise2 = taiDuLieu(\u0026#34;api.example.com/posts\u0026#34;); const promise3 = taiDuLieu(\u0026#34;api.example.com/comments\u0026#34;); Promise.all([promise1, promise2, promise3]) .then(ketQua =\u0026gt; { const [users, posts, comments] = ketQua; console.log(\u0026#34;Tất cả dữ liệu đã tải xong\u0026#34;); console.log(\u0026#34;Users:\u0026#34;, users); console.log(\u0026#34;Posts:\u0026#34;, posts); console.log(\u0026#34;Comments:\u0026#34;, comments); }) .catch(error =\u0026gt; { console.error(\u0026#34;Một trong các promises đã thất bại:\u0026#34;, error.message); }); Promise.race Promise.race trả về promise đầu tiên hoàn thành (hoặc bị từ chối).\nconst promise1 = taiDuLieu(\u0026#34;api.example.com/data1\u0026#34;); // 2 giây const promise2 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Dữ liệu nhanh\u0026#34;), 1000); // 1 giây }); Promise.race([promise1, promise2]) .then(ketQua =\u0026gt; { console.log(\u0026#34;Kết quả đầu tiên:\u0026#34;, ketQua); // \u0026#34;Dữ liệu nhanh\u0026#34; }) .catch(error =\u0026gt; { console.error(\u0026#34;Lỗi:\u0026#34;, error.message); }); Async/Await Async/await là cú pháp \u0026ldquo;đường mật\u0026rdquo; (syntactic sugar) cho promises, giúp code bất đồng bộ trông giống như code đồng bộ, dễ đọc và dễ hiểu hơn.\nasync function taiDuLieuNguoiDung() { try { console.log(\u0026#34;Bắt đầu tải dữ liệu người dùng\u0026#34;); const users = await taiDuLieu(\u0026#34;api.example.com/users\u0026#34;); console.log(\u0026#34;Danh sách người dùng:\u0026#34;, users); const posts = await taiDuLieu(`api.example.com/users/${users.id}/posts`); console.log(\u0026#34;Bài viết của người dùng:\u0026#34;, posts); const comments = await taiDuLieu(`api.example.com/posts/${posts.id}/comments`); console.log(\u0026#34;Bình luận của bài viết:\u0026#34;, comments); return { users, posts, comments }; } catch (error) { console.error(\u0026#34;Đã xảy ra lỗi:\u0026#34;, error.message); throw error; } finally { console.log(\u0026#34;Quá trình tải dữ liệu đã hoàn tất\u0026#34;); } } // Gọi hàm async taiDuLieuNguoiDung() .then(duLieu =\u0026gt; { console.log(\u0026#34;Tất cả dữ liệu:\u0026#34;, duLieu); }) .catch(error =\u0026gt; { console.error(\u0026#34;Lỗi từ hàm async:\u0026#34;, error.message); }); console.log(\u0026#34;Tiếp tục thực hiện các tác vụ khác...\u0026#34;); Thực Hiện Nhiều Tác Vụ Đồng Thời Với Async/Await async function taiNhieuDuLieu() { try { console.log(\u0026#34;Bắt đầu tải nhiều dữ liệu đồng thời\u0026#34;); // Thực hiện đồng thời const [users, posts, comments] = await Promise.all([ taiDuLieu(\u0026#34;api.example.com/users\u0026#34;), taiDuLieu(\u0026#34;api.example.com/posts\u0026#34;), taiDuLieu(\u0026#34;api.example.com/comments\u0026#34;) ]); console.log(\u0026#34;Tất cả dữ liệu đã tải xong\u0026#34;); console.log(\u0026#34;Users:\u0026#34;, users); console.log(\u0026#34;Posts:\u0026#34;, posts); console.log(\u0026#34;Comments:\u0026#34;, comments); return { users, posts, comments }; } catch (error) { console.error(\u0026#34;Đã xảy ra lỗi:\u0026#34;, error.message); throw error; } } Ví Dụ Thực Tế: Gọi API Sử Dụng Fetch API Với Promises function layDuLieuAPI(url) { return fetch(url) .then(response =\u0026gt; { if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } return response.json(); }); } layDuLieuAPI(\u0026#39;https://jsonplaceholder.typicode.com/users\u0026#39;) .then(users =\u0026gt; { console.log(\u0026#34;Danh sách người dùng:\u0026#34;, users); return layDuLieuAPI(`https://jsonplaceholder.typicode.com/users/${users[0].id}/posts`); }) .then(posts =\u0026gt; { console.log(\u0026#34;Bài viết của người dùng:\u0026#34;, posts); }) .catch(error =\u0026gt; { console.error(\u0026#34;Lỗi khi gọi API:\u0026#34;, error.message); }); Sử Dụng Fetch API Với Async/Await async function layDuLieuAPI(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } return await response.json(); } catch (error) { console.error(\u0026#34;Lỗi khi gọi API:\u0026#34;, error.message); throw error; } } async function hienThiDuLieuNguoiDung() { try { const users = await layDuLieuAPI(\u0026#39;https://jsonplaceholder.typicode.com/users\u0026#39;); console.log(\u0026#34;Danh sách người dùng:\u0026#34;, users); const posts = await layDuLieuAPI(`https://jsonplaceholder.typicode.com/users/${users[0].id}/posts`); console.log(\u0026#34;Bài viết của người dùng:\u0026#34;, posts); return { users, posts }; } catch (error) { console.error(\u0026#34;Không thể hiển thị dữ liệu:\u0026#34;, error.message); } } hienThiDuLieuNguoiDung(); Kết Luận Lập trình bất đồng bộ là một phần quan trọng của JavaScript, đặc biệt trong phát triển web hiện đại. Promises và async/await cung cấp các cách mạnh mẽ và dễ đọc để xử lý các tác vụ bất đồng bộ, giúp tránh callback hell và làm cho mã nguồn dễ bảo trì hơn.\nTrong các bài viết tiếp theo, chúng ta sẽ tìm hiểu về các framework JavaScript hiện đại và cách chúng xử lý các tác vụ bất đồng bộ.\n","permalink":"http://localhost:1313/posts/javascript-async/","summary":"\u003ch1 id=\"javascript-bất-đồng-bộ---promises-asyncawait\"\u003eJavaScript Bất Đồng Bộ - Promises, Async/Await\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"JavaScript Async\" loading=\"lazy\" src=\"/images/posts/javascript-async.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eJavaScript là ngôn ngữ đơn luồng (single-threaded), nhưng có thể xử lý các tác vụ bất đồng bộ thông qua các cơ chế như callbacks, promises, và async/await.\u003c/p\u003e\n\u003ch2 id=\"tại-sao-cần-lập-trình-bất-đồng-bộ\"\u003eTại Sao Cần Lập Trình Bất Đồng Bộ?\u003c/h2\u003e\n\u003cp\u003eLập trình bất đồng bộ cho phép thực hiện các tác vụ mà không chặn luồng chính, đặc biệt hữu ích cho:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGọi API\u003c/li\u003e\n\u003cli\u003eĐọc/ghi tệp\u003c/li\u003e\n\u003cli\u003eTruy vấn cơ sở dữ liệu\u003c/li\u003e\n\u003cli\u003eTải tài nguyên (hình ảnh, video)\u003c/li\u003e\n\u003cli\u003eThực hiện các tác vụ tốn thời gian\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"callbacks\"\u003eCallbacks\u003c/h2\u003e\n\u003cp\u003eCallbacks là cách truyền thống nhất để xử lý bất đồng bộ trong JavaScript.\u003c/p\u003e","title":"JavaScript Bất Đồng Bộ - Promises, Async/Await"},{"content":"JavaScript DOM - Tương Tác Với Trang Web Document Object Model (DOM) là một giao diện lập trình cho phép JavaScript tương tác với HTML và CSS, giúp tạo ra các trang web động và tương tác.\nDOM Là Gì? DOM biểu diễn trang web dưới dạng cấu trúc cây, trong đó mỗi thẻ HTML là một nút (node). JavaScript có thể truy cập và thay đổi tất cả các phần tử trong cây DOM này.\ndocument └── html ├── head │ ├── title │ └── meta └── body ├── header ├── div │ ├── h1 │ └── p └── footer Truy Cập Các Phần Tử DOM JavaScript cung cấp nhiều phương thức để truy cập các phần tử DOM:\n// Truy cập theo ID const tieuDe = document.getElementById(\u0026#34;tieuDe\u0026#34;); // Truy cập theo tên thẻ const doanVan = document.getElementsByTagName(\u0026#34;p\u0026#34;); // Truy cập theo tên lớp const mucLuc = document.getElementsByClassName(\u0026#34;muc-luc\u0026#34;); // Truy cập bằng CSS selector const nutBam = document.querySelector(\u0026#34;#nut-bam\u0026#34;); const cacMucLuc = document.querySelectorAll(\u0026#34;.muc-luc\u0026#34;); Thay Đổi Nội Dung DOM Sau khi truy cập được phần tử, bạn có thể thay đổi nội dung của nó:\n// Thay đổi nội dung văn bản tieuDe.textContent = \u0026#34;Tiêu đề mới\u0026#34;; // Thay đổi HTML tieuDe.innerHTML = \u0026#34;Tiêu đề \u0026lt;span style=\u0026#39;color: red;\u0026#39;\u0026gt;mới\u0026lt;/span\u0026gt;\u0026#34;; // Thay đổi thuộc tính const hinhAnh = document.getElementById(\u0026#34;hinh-anh\u0026#34;); hinhAnh.src = \u0026#34;duong-dan-moi.jpg\u0026#34;; hinhAnh.alt = \u0026#34;Mô tả mới\u0026#34;; // Thêm/xóa lớp CSS tieuDe.classList.add(\u0026#34;noi-bat\u0026#34;); tieuDe.classList.remove(\u0026#34;an\u0026#34;); tieuDe.classList.toggle(\u0026#34;hien-thi\u0026#34;); // Thay đổi kiểu trực tiếp tieuDe.style.color = \u0026#34;blue\u0026#34;; tieuDe.style.fontSize = \u0026#34;24px\u0026#34;; tieuDe.style.fontWeight = \u0026#34;bold\u0026#34;; Tạo và Xóa Phần Tử JavaScript cho phép tạo và xóa các phần tử DOM:\n// Tạo phần tử mới const doanVanMoi = document.createElement(\u0026#34;p\u0026#34;); doanVanMoi.textContent = \u0026#34;Đây là đoạn văn mới.\u0026#34;; // Thêm phần tử vào DOM document.body.appendChild(doanVanMoi); // Thêm phần tử vào vị trí cụ thể const phanNoiDung = document.getElementById(\u0026#34;noi-dung\u0026#34;); phanNoiDung.insertBefore(doanVanMoi, phanNoiDung.firstChild); // Xóa phần tử const phanTuCanXoa = document.getElementById(\u0026#34;phan-tu-can-xoa\u0026#34;); phanTuCanXoa.remove(); // Hoặc xóa thông qua phần tử cha const phanTuCha = document.getElementById(\u0026#34;phan-tu-cha\u0026#34;); const phanTuCon = document.getElementById(\u0026#34;phan-tu-con\u0026#34;); phanTuCha.removeChild(phanTuCon); Xử Lý Sự Kiện Sự kiện cho phép JavaScript phản hồi các hành động của người dùng:\n// Thêm trình xử lý sự kiện const nutBam = document.getElementById(\u0026#34;nut-bam\u0026#34;); nutBam.addEventListener(\u0026#34;click\u0026#34;, function() { alert(\u0026#34;Bạn đã nhấn vào nút!\u0026#34;); }); // Sử dụng arrow function nutBam.addEventListener(\u0026#34;mouseover\u0026#34;, () =\u0026gt; { nutBam.style.backgroundColor = \u0026#34;lightblue\u0026#34;; }); nutBam.addEventListener(\u0026#34;mouseout\u0026#34;, () =\u0026gt; { nutBam.style.backgroundColor = \u0026#34;\u0026#34;; }); // Xóa trình xử lý sự kiện function xuLyClick() { alert(\u0026#34;Xử lý click!\u0026#34;); } nutBam.addEventListener(\u0026#34;click\u0026#34;, xuLyClick); // Sau đó, khi không cần nữa nutBam.removeEventListener(\u0026#34;click\u0026#34;, xuLyClick); Sự Kiện Phổ Biến JavaScript hỗ trợ nhiều loại sự kiện:\n// Sự kiện chuột element.addEventListener(\u0026#34;click\u0026#34;, xuLy); // Nhấp chuột element.addEventListener(\u0026#34;dblclick\u0026#34;, xuLy); // Nhấp đúp element.addEventListener(\u0026#34;mouseover\u0026#34;, xuLy); // Di chuột vào element.addEventListener(\u0026#34;mouseout\u0026#34;, xuLy); // Di chuột ra element.addEventListener(\u0026#34;mousedown\u0026#34;, xuLy); // Nhấn chuột xuống element.addEventListener(\u0026#34;mouseup\u0026#34;, xuLy); // Thả chuột // Sự kiện bàn phím element.addEventListener(\u0026#34;keydown\u0026#34;, xuLy); // Nhấn phím xuống element.addEventListener(\u0026#34;keyup\u0026#34;, xuLy); // Thả phím element.addEventListener(\u0026#34;keypress\u0026#34;, xuLy); // Nhấn phím (ký tự) // Sự kiện form form.addEventListener(\u0026#34;submit\u0026#34;, xuLy); // Gửi form input.addEventListener(\u0026#34;change\u0026#34;, xuLy); // Thay đổi giá trị input.addEventListener(\u0026#34;focus\u0026#34;, xuLy); // Focus vào input input.addEventListener(\u0026#34;blur\u0026#34;, xuLy); // Mất focus // Sự kiện window window.addEventListener(\u0026#34;load\u0026#34;, xuLy); // Trang đã tải xong window.addEventListener(\u0026#34;resize\u0026#34;, xuLy); // Thay đổi kích thước cửa sổ window.addEventListener(\u0026#34;scroll\u0026#34;, xuLy); // Cuộn trang Ví Dụ Thực Tế Ví dụ 1: Tạo danh sách động function themMucDanhSach() { // Lấy giá trị từ input const input = document.getElementById(\u0026#34;muc-moi\u0026#34;); const giaTriMoi = input.value.trim(); if (giaTriMoi !== \u0026#34;\u0026#34;) { // Tạo phần tử mới const mucMoi = document.createElement(\u0026#34;li\u0026#34;); mucMoi.textContent = giaTriMoi; // Thêm nút xóa const nutXoa = document.createElement(\u0026#34;button\u0026#34;); nutXoa.textContent = \u0026#34;Xóa\u0026#34;; nutXoa.className = \u0026#34;nut-xoa\u0026#34;; nutXoa.onclick = function() { mucMoi.remove(); }; mucMoi.appendChild(nutXoa); // Thêm vào danh sách document.getElementById(\u0026#34;danh-sach\u0026#34;).appendChild(mucMoi); // Xóa giá trị input input.value = \u0026#34;\u0026#34;; } } // Thêm sự kiện cho nút document.getElementById(\u0026#34;nut-them\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, themMucDanhSach); Ví dụ 2: Xác thực form document.getElementById(\u0026#34;form-dang-ky\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, function(event) { let coLoi = false; // Kiểm tra tên const ten = document.getElementById(\u0026#34;ten\u0026#34;).value.trim(); if (ten === \u0026#34;\u0026#34;) { document.getElementById(\u0026#34;loi-ten\u0026#34;).textContent = \u0026#34;Vui lòng nhập tên\u0026#34;; coLoi = true; } else { document.getElementById(\u0026#34;loi-ten\u0026#34;).textContent = \u0026#34;\u0026#34;; } // Kiểm tra email const email = document.getElementById(\u0026#34;email\u0026#34;).value.trim(); const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; if (!emailRegex.test(email)) { document.getElementById(\u0026#34;loi-email\u0026#34;).textContent = \u0026#34;Email không hợp lệ\u0026#34;; coLoi = true; } else { document.getElementById(\u0026#34;loi-email\u0026#34;).textContent = \u0026#34;\u0026#34;; } // Nếu có lỗi, ngăn form gửi đi if (coLoi) { event.preventDefault(); } }); Kết Luận DOM là một công cụ mạnh mẽ cho phép JavaScript tương tác với trang web, tạo ra trải nghiệm người dùng động và tương tác. Hiểu và sử dụng DOM hiệu quả là kỹ năng cần thiết cho bất kỳ nhà phát triển web nào.\nTrong các bài viết tiếp theo, chúng ta sẽ tìm hiểu về các thư viện và framework JavaScript hiện đại như React, Vue.js, và Angular, giúp đơn giản hóa việc thao tác DOM và xây dựng ứng dụng web phức tạp.\n","permalink":"http://localhost:1313/posts/javascript-dom/","summary":"\u003ch1 id=\"javascript-dom---tương-tác-với-trang-web\"\u003eJavaScript DOM - Tương Tác Với Trang Web\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"JavaScript DOM\" loading=\"lazy\" src=\"/images/posts/javascript-dom.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eDocument Object Model (DOM) là một giao diện lập trình cho phép JavaScript tương tác với HTML và CSS, giúp tạo ra các trang web động và tương tác.\u003c/p\u003e\n\u003ch2 id=\"dom-là-gì\"\u003eDOM Là Gì?\u003c/h2\u003e\n\u003cp\u003eDOM biểu diễn trang web dưới dạng cấu trúc cây, trong đó mỗi thẻ HTML là một nút (node). JavaScript có thể truy cập và thay đổi tất cả các phần tử trong cây DOM này.\u003c/p\u003e","title":"JavaScript DOM - Tương Tác Với Trang Web"},{"content":"JavaScript ES6 - Những Tính Năng Hiện Đại ECMAScript 6 (ES6), còn được gọi là ECMAScript 2015, là một bản cập nhật lớn cho JavaScript, giới thiệu nhiều tính năng mới giúp viết mã dễ dàng và hiệu quả hơn.\nCác Tính Năng Chính Của ES6 1. Let và Const ES6 giới thiệu hai từ khóa mới để khai báo biến: let và const.\n// let - phạm vi block let x = 10; if (true) { let x = 20; // Biến x khác với x ở ngoài console.log(x); // 20 } console.log(x); // 10 // const - hằng số const PI = 3.14; // PI = 3.15; // Lỗi: không thể gán lại giá trị cho hằng số 2. Arrow Functions Arrow functions cung cấp cú pháp ngắn gọn hơn để viết biểu thức hàm.\n// Hàm thông thường function tong(a, b) { return a + b; } // Arrow function const tongArrow = (a, b) =\u0026gt; a + b; // Arrow function với nhiều dòng const kiemTra = (so) =\u0026gt; { if (so \u0026gt; 0) { return \u0026#34;Dương\u0026#34;; } else { return \u0026#34;Âm hoặc Zero\u0026#34;; } }; 3. Template Literals Template literals cho phép nhúng biểu thức vào chuỗi và viết chuỗi nhiều dòng dễ dàng.\nconst ten = \u0026#34;JavaScript\u0026#34;; const nam = 1995; // Chuỗi thông thường console.log(\u0026#34;Ngôn ngữ \u0026#34; + ten + \u0026#34; ra đời năm \u0026#34; + nam); // Template literal console.log(`Ngôn ngữ ${ten} ra đời năm ${nam}`); // Chuỗi nhiều dòng const html = ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Tiêu đề\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Đoạn văn\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; 4. Destructuring Assignment Destructuring cho phép trích xuất dữ liệu từ mảng hoặc đối tượng vào các biến riêng biệt.\n// Destructuring mảng const mang = [1, 2, 3]; const [a, b, c] = mang; console.log(a, b, c); // 1 2 3 // Destructuring đối tượng const nguoi = { ten: \u0026#34;Nguyễn Văn A\u0026#34;, tuoi: 30, diaChi: \u0026#34;Hà Nội\u0026#34; }; const { ten, tuoi, diaChi } = nguoi; console.log(ten, tuoi, diaChi); // Nguyễn Văn A 30 Hà Nội // Đổi tên biến khi destructuring const { ten: hoTen, tuoi: namSinh } = nguoi; console.log(hoTen, namSinh); // Nguyễn Văn A 30 5. Default Parameters ES6 cho phép thiết lập giá trị mặc định cho tham số hàm.\nfunction xinChao(ten = \u0026#34;Bạn\u0026#34;) { console.log(`Xin chào, ${ten}!`); } xinChao(); // Xin chào, Bạn! xinChao(\u0026#34;Nguyễn Văn A\u0026#34;); // Xin chào, Nguyễn Văn A! 6. Rest Parameters và Spread Operator Rest parameters cho phép biểu diễn một số lượng đối số không xác định dưới dạng một mảng.\nfunction tinhTong(...soHang) { return soHang.reduce((tong, so) =\u0026gt; tong + so, 0); } console.log(tinhTong(1, 2, 3, 4, 5)); // 15 Spread operator cho phép mở rộng một mảng hoặc đối tượng.\n// Mở rộng mảng const mang1 = [1, 2, 3]; const mang2 = [...mang1, 4, 5]; console.log(mang2); // [1, 2, 3, 4, 5] // Mở rộng đối tượng const nguoi = { ten: \u0026#34;Nguyễn Văn A\u0026#34;, tuoi: 30 }; const nguoiChiTiet = { ...nguoi, diaChi: \u0026#34;Hà Nội\u0026#34;, ngheNghiep: \u0026#34;Lập trình viên\u0026#34; }; console.log(nguoiChiTiet); // { ten: \u0026#34;Nguyễn Văn A\u0026#34;, tuoi: 30, diaChi: \u0026#34;Hà Nội\u0026#34;, ngheNghiep: \u0026#34;Lập trình viên\u0026#34; } 7. Classes ES6 giới thiệu cú pháp lớp, giúp lập trình hướng đối tượng dễ dàng hơn.\nclass NguoiDung { constructor(ten, email) { this.ten = ten; this.email = email; } xinChao() { console.log(`Xin chào, tôi là ${this.ten}`); } static kiemTraEmail(email) { return email.includes(\u0026#39;@\u0026#39;); } } const nguoiDung = new NguoiDung(\u0026#34;Nguyễn Văn A\u0026#34;, \u0026#34;nguyenvana@example.com\u0026#34;); nguoiDung.xinChao(); // Xin chào, tôi là Nguyễn Văn A // Kế thừa class QuanTriVien extends NguoiDung { constructor(ten, email, quyen) { super(ten, email); this.quyen = quyen; } kiemTraQuyen() { console.log(`${this.ten} có quyền: ${this.quyen}`); } } const admin = new QuanTriVien(\u0026#34;Admin\u0026#34;, \u0026#34;admin@example.com\u0026#34;, \u0026#34;Toàn quyền\u0026#34;); admin.xinChao(); // Xin chào, tôi là Admin admin.kiemTraQuyen(); // Admin có quyền: Toàn quyền 8. Promises Promises cung cấp một cách tốt hơn để xử lý các hoạt động bất đồng bộ.\nfunction taiDuLieu(url) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (url) { resolve(`Dữ liệu từ ${url}`); } else { reject(\u0026#34;URL không hợp lệ\u0026#34;); } }, 1000); }); } taiDuLieu(\u0026#34;api.example.com/data\u0026#34;) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(error)); 9. Modules ES6 giới thiệu hệ thống module tích hợp, cho phép chia mã thành các phần nhỏ hơn, dễ quản lý.\n// math.js export function tinhTong(a, b) { return a + b; } export function tinhHieu(a, b) { return a - b; } // main.js import { tinhTong, tinhHieu } from \u0026#39;./math.js\u0026#39;; console.log(tinhTong(5, 3)); // 8 console.log(tinhHieu(5, 3)); // 2 // Hoặc import tất cả import * as Math from \u0026#39;./math.js\u0026#39;; console.log(Math.tinhTong(5, 3)); // 8 console.log(Math.tinhHieu(5, 3)); // 2 Kết Luận ES6 đã mang lại nhiều cải tiến đáng kể cho JavaScript, giúp mã nguồn trở nên sạch sẽ, dễ đọc và dễ bảo trì hơn. Các tính năng này đã trở thành tiêu chuẩn trong phát triển JavaScript hiện đại.\nTrong các bài viết tiếp theo, chúng ta sẽ tìm hiểu về các tính năng mới trong các phiên bản ECMAScript sau ES6, cũng như các framework và thư viện JavaScript phổ biến.\n","permalink":"http://localhost:1313/posts/javascript-es6/","summary":"\u003ch1 id=\"javascript-es6---những-tính-năng-hiện-đại\"\u003eJavaScript ES6 - Những Tính Năng Hiện Đại\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"JavaScript ES6\" loading=\"lazy\" src=\"/images/posts/javascript-es6.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eECMAScript 6 (ES6), còn được gọi là ECMAScript 2015, là một bản cập nhật lớn cho JavaScript, giới thiệu nhiều tính năng mới giúp viết mã dễ dàng và hiệu quả hơn.\u003c/p\u003e\n\u003ch2 id=\"các-tính-năng-chính-của-es6\"\u003eCác Tính Năng Chính Của ES6\u003c/h2\u003e\n\u003ch3 id=\"1-let-và-const\"\u003e1. Let và Const\u003c/h3\u003e\n\u003cp\u003eES6 giới thiệu hai từ khóa mới để khai báo biến: \u003ccode\u003elet\u003c/code\u003e và \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// let - phạm vi block\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e20\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// Biến x khác với x ở ngoài\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 20\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// const - hằng số\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePI\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3.14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// PI = 3.15; // Lỗi: không thể gán lại giá trị cho hằng số\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-arrow-functions\"\u003e2. Arrow Functions\u003c/h3\u003e\n\u003cp\u003eArrow functions cung cấp cú pháp ngắn gọn hơn để viết biểu thức hàm.\u003c/p\u003e","title":"JavaScript ES6 - Những Tính Năng Hiện Đại"},{"content":"Lập Trình Hướng Đối Tượng Trong Java Lập trình hướng đối tượng (Object-Oriented Programming - OOP) là một trong những đặc điểm quan trọng nhất của Java. Bài viết này sẽ giới thiệu các khái niệm cơ bản về OOP trong Java.\nCác Nguyên Lý Cơ Bản Của OOP 1. Tính Đóng Gói (Encapsulation) Tính đóng gói cho phép ẩn các chi tiết triển khai và chỉ hiển thị chức năng cần thiết cho người dùng.\npublic class SinhVien { // Thuộc tính private private String hoTen; private int tuoi; // Getter và Setter public String getHoTen() { return hoTen; } public void setHoTen(String hoTen) { this.hoTen = hoTen; } public int getTuoi() { return tuoi; } public void setTuoi(int tuoi) { if (tuoi \u0026gt; 0) { this.tuoi = tuoi; } } } 2. Tính Kế Thừa (Inheritance) Tính kế thừa cho phép một lớp (lớp con) kế thừa các thuộc tính và phương thức từ một lớp khác (lớp cha).\n// Lớp cha public class NguoiDung { protected String tenDangNhap; protected String matKhau; public void dangNhap() { System.out.println(\u0026#34;Đăng nhập với tên: \u0026#34; + tenDangNhap); } } // Lớp con public class QuanTriVien extends NguoiDung { private int capDoQuyen; public void quanLyHeThong() { System.out.println(\u0026#34;Quản lý hệ thống với quyền cấp: \u0026#34; + capDoQuyen); } } 3. Tính Đa Hình (Polymorphism) Tính đa hình cho phép các đối tượng của các lớp khác nhau được xử lý thông qua một giao diện chung.\n// Lớp cha public class HinhHoc { public double tinhDienTich() { return 0; } } // Lớp con 1 public class HinhTron extends HinhHoc { private double banKinh; public HinhTron(double banKinh) { this.banKinh = banKinh; } @Override public double tinhDienTich() { return Math.PI * banKinh * banKinh; } } // Lớp con 2 public class HinhChuNhat extends HinhHoc { private double chieuDai; private double chieuRong; public HinhChuNhat(double chieuDai, double chieuRong) { this.chieuDai = chieuDai; this.chieuRong = chieuRong; } @Override public double tinhDienTich() { return chieuDai * chieuRong; } } // Sử dụng tính đa hình public class Main { public static void main(String[] args) { HinhHoc hinh1 = new HinhTron(5); HinhHoc hinh2 = new HinhChuNhat(4, 6); System.out.println(\u0026#34;Diện tích hình tròn: \u0026#34; + hinh1.tinhDienTich()); System.out.println(\u0026#34;Diện tích hình chữ nhật: \u0026#34; + hinh2.tinhDienTich()); } } 4. Tính Trừu Tượng (Abstraction) Tính trừu tượng cho phép tập trung vào những gì một đối tượng làm thay vì cách nó thực hiện.\n// Lớp trừu tượng public abstract class DongVat { protected String ten; public abstract void keu(); public void an() { System.out.println(ten + \u0026#34; đang ăn...\u0026#34;); } } // Lớp con triển khai public class Cho extends DongVat { public Cho(String ten) { this.ten = ten; } @Override public void keu() { System.out.println(ten + \u0026#34; kêu: Gâu gâu!\u0026#34;); } } public class Meo extends DongVat { public Meo(String ten) { this.ten = ten; } @Override public void keu() { System.out.println(ten + \u0026#34; kêu: Meo meo!\u0026#34;); } } Lớp Và Đối Tượng Trong Java Lớp (Class) Lớp là một bản thiết kế hoặc nguyên mẫu để tạo ra các đối tượng. Nó định nghĩa các thuộc tính và phương thức mà các đối tượng của lớp đó sẽ có.\npublic class SanPham { // Thuộc tính private String ten; private double gia; private int soLuong; // Constructor public SanPham(String ten, double gia, int soLuong) { this.ten = ten; this.gia = gia; this.soLuong = soLuong; } // Phương thức public double tinhTongGia() { return gia * soLuong; } public void hienThiThongTin() { System.out.println(\u0026#34;Tên: \u0026#34; + ten); System.out.println(\u0026#34;Giá: \u0026#34; + gia); System.out.println(\u0026#34;Số lượng: \u0026#34; + soLuong); System.out.println(\u0026#34;Tổng giá: \u0026#34; + tinhTongGia()); } } Đối Tượng (Object) Đối tượng là một thể hiện của lớp, được tạo ra từ bản thiết kế của lớp.\npublic class Main { public static void main(String[] args) { // Tạo đối tượng từ lớp SanPham SanPham sp1 = new SanPham(\u0026#34;Laptop\u0026#34;, 15000000, 2); SanPham sp2 = new SanPham(\u0026#34;Điện thoại\u0026#34;, 8000000, 3); // Sử dụng các phương thức của đối tượng sp1.hienThiThongTin(); sp2.hienThiThongTin(); } } Kết Luận Lập trình hướng đối tượng là một phương pháp mạnh mẽ trong Java, giúp tổ chức mã nguồn một cách có cấu trúc, dễ bảo trì và mở rộng. Hiểu và áp dụng đúng các nguyên lý OOP sẽ giúp bạn trở thành một lập trình viên Java giỏi.\nTrong các bài viết tiếp theo, chúng ta sẽ tìm hiểu sâu hơn về các khía cạnh nâng cao của OOP trong Java như interface, lớp trừu tượng, và các mẫu thiết kế phổ biến.\n","permalink":"http://localhost:1313/posts/java-oop/","summary":"\u003ch1 id=\"lập-trình-hướng-đối-tượng-trong-java\"\u003eLập Trình Hướng Đối Tượng Trong Java\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Java OOP\" loading=\"lazy\" src=\"/images/posts/java-oop.svg\"\u003e\u003c/p\u003e\n\u003cp\u003eLập trình hướng đối tượng (Object-Oriented Programming - OOP) là một trong những đặc điểm quan trọng nhất của Java. Bài viết này sẽ giới thiệu các khái niệm cơ bản về OOP trong Java.\u003c/p\u003e\n\u003ch2 id=\"các-nguyên-lý-cơ-bản-của-oop\"\u003eCác Nguyên Lý Cơ Bản Của OOP\u003c/h2\u003e\n\u003ch3 id=\"1-tính-đóng-gói-encapsulation\"\u003e1. Tính Đóng Gói (Encapsulation)\u003c/h3\u003e\n\u003cp\u003eTính đóng gói cho phép ẩn các chi tiết triển khai và chỉ hiển thị chức năng cần thiết cho người dùng.\u003c/p\u003e","title":"Lập Trình Hướng Đối Tượng Trong Java"},{"content":"Giới Thiệu Xin chào! Tôi là một lập trình viên đam mê với công nghệ và phát triển phần mềm. Blog này được tạo ra để chia sẻ kiến thức và kinh nghiệm của tôi trong lĩnh vực lập trình, đặc biệt là Java và JavaScript.\nKỹ Năng Ngôn ngữ lập trình: Java, JavaScript, HTML, CSS Frameworks \u0026amp; Libraries: Spring Boot, React, Node.js Công cụ phát triển: Git, Docker, VS Code, IntelliJ IDEA Cơ sở dữ liệu: MySQL, MongoDB Học Vấn Cử nhân Khoa học Máy tính Các khóa học online về phát triển web và ứng dụng di động Dự Án Nổi Bật Ứng dụng quản lý công việc Phát triển ứng dụng web quản lý công việc sử dụng Spring Boot và React, giúp người dùng theo dõi và quản lý các nhiệm vụ hàng ngày.\nWebsite thương mại điện tử Xây dựng website thương mại điện tử với đầy đủ tính năng như giỏ hàng, thanh toán, quản lý sản phẩm sử dụng MERN stack.\nLiên Hệ Email: example@email.com GitHub: github.com/username LinkedIn: linkedin.com/in/username Cảm ơn bạn đã ghé thăm trang hồ sơ của tôi. Hãy khám phá các bài viết trên blog để tìm hiểu thêm về lập trình Java và JavaScript!\n","permalink":"http://localhost:1313/profile/","summary":"\u003ch1 id=\"giới-thiệu\"\u003eGiới Thiệu\u003c/h1\u003e\n\u003cp\u003eXin chào! Tôi là một lập trình viên đam mê với công nghệ và phát triển phần mềm. Blog này được tạo ra để chia sẻ kiến thức và kinh nghiệm của tôi trong lĩnh vực lập trình, đặc biệt là Java và JavaScript.\u003c/p\u003e\n\u003ch2 id=\"kỹ-năng\"\u003eKỹ Năng\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNgôn ngữ lập trình\u003c/strong\u003e: Java, JavaScript, HTML, CSS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFrameworks \u0026amp; Libraries\u003c/strong\u003e: Spring Boot, React, Node.js\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCông cụ phát triển\u003c/strong\u003e: Git, Docker, VS Code, IntelliJ IDEA\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCơ sở dữ liệu\u003c/strong\u003e: MySQL, MongoDB\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"học-vấn\"\u003eHọc Vấn\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCử nhân Khoa học Máy tính\u003c/li\u003e\n\u003cli\u003eCác khóa học online về phát triển web và ứng dụng di động\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dự-án-nổi-bật\"\u003eDự Án Nổi Bật\u003c/h2\u003e\n\u003ch3 id=\"ứng-dụng-quản-lý-công-việc\"\u003eỨng dụng quản lý công việc\u003c/h3\u003e\n\u003cp\u003ePhát triển ứng dụng web quản lý công việc sử dụng Spring Boot và React, giúp người dùng theo dõi và quản lý các nhiệm vụ hàng ngày.\u003c/p\u003e","title":"Hồ Sơ Cá Nhân"}]